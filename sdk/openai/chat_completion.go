package openai

import (
	"fmt"

	"github.com/askasoft/pango/str"
)

const (
	RoleDeveloper = "developer"
	RoleSystem    = "system"
	RoleUser      = "user"
	RoleAssistant = "assistant"
	RoleTool      = "tool"
)

type ChatMessage struct {
	// The role of the messages author. One of system, user, assistant, or function.
	Role string `json:"role,omitempty"`

	// The contents of the message.
	// string or []*MessageContent
	// content is required for all messages, and may be null for assistant messages with function calls.
	Content any `json:"content,omitempty"`

	// The name of the author of this message. name is required if role is function, and it should be the name of the function whose response is in the content. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
	Name string `json:"name,omitempty"`

	// The refusal message by the assistant.
	Refusal string `json:"refusal,omitempty"`

	// Tool call that this message is responding to. required if role is tool.
	ToolCallID string `json:"tool_call_id,omitempty"`

	// The tool calls generated by the model, such as function calls.
	ToolCalls []*ToolCall `json:"tool_calls,omitempty"`
}

type Function struct {
	// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
	Arguments string `json:"arguments,omitempty"`

	// The name of the function to call.
	Name string `json:"name,omitempty"`
}

type ToolCall struct {
	// The ID of the tool call.
	ID string `json:"id,omitempty"`

	// The type of the tool. Currently, only function is supported.
	Type string `json:"type,omitempty"`

	// The function that the model called.
	Function *Function `json:"function,omitempty"`
}

type ImageURL struct {
	// Either a URL of the image or the base64 encoded image data.
	URL string `json:"url,omitempty"`

	// Specifies the detail level of the image. Learn more in the Vision guide.
	Detail string `json:"detail,omitempty"`
}

type InputAudio struct {
	// Base64 encoded audio data.
	Data string `json:"data,omitempty"`

	// The format of the encoded audio data. Currently supports "wav" and "mp3".
	Format string `json:"format,omitempty"`
}

type InputFile struct {
	// The base64 encoded file data, used when passing the file to the model as a string.
	FileData string `json:"file_data,omitempty"`

	// The ID of an uploaded file to use as input.
	FileID string `json:"file_id,omitempty"`

	// The name of the file, used when passing the file to the model as a string.
	Filename string `json:"filename,omitempty"`
}

type MessageContent struct {
	Type       string      `json:"type,omitempty"`
	Text       string      `json:"text,omitempty"`
	ImageURL   *ImageURL   `json:"image_url,omitempty"`
	InputAudio *InputAudio `json:"input_audio,omitempty"`
	File       *InputFile  `json:"file,omitempty"`
}

type ChatFunction struct {
	// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name,omitempty"`

	// A description of what the function does, used by the model to choose when and how to call the function.
	Description string `json:"description,omitempty"`

	// The parameters the functions accepts, described as a JSON Schema object. See the guide for examples, and the JSON Schema reference for documentation about the format.
	// To describe a function that accepts no parameters, provide the value {"type": "object", "properties": {}}.
	Parameters map[string]any `json:"parameters,omitempty"`
}

type AudioOutput struct {
	// Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
	Format string `json:"format,omitempty"`

	// The voice the model uses to respond. Supported voices are alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer.
	Voice string `json:"voice,omitempty"`
}

type Prediction struct {
	// The content that should be matched when generating a model response.
	// If generated tokens would match this content, the entire model response can be returned much more quickly.
	// string or array
	Content any `json:"content,omitempty"`

	// The type of the predicted content you want to provide. This type is currently always content.
	Type string `json:"type,omitempty"`
}

type JSONSchema struct {
	// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// A description of what the response format is for, used by the model to determine how to respond in the format.
	Description string `json:"description,omitempty"`

	// The schema for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
	Schema any `json:"schema,omitempty"`

	// Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true. To learn more, read the Structured Outputs guide.
	Strict bool `json:"strict,omitempty"`
}

type ResponseFormat struct {
	// The type of response format being defined. "text" or "json_schema" or "json_object".
	Type string `json:"type"`

	JsonSchema *JSONSchema `json:"json_schema,omitempty"`
}

type Approximate struct {
	// Free text input for the city of the user, e.g. San Francisco.
	City string `json:"city,omitempty"`

	// The two-letter ISO country code of the user, e.g. US.
	Country string `json:"country,omitempty"`

	// Free text input for the region of the user, e.g. California.
	Region string `json:"region,omitempty"`

	// The IANA timezone of the user, e.g. America/Los_Angeles.
	Timezone string `json:"timezone,omitempty"`
}

type UserLocation struct {
	// Approximate location parameters for the search.
	Approximate *Approximate `json:"approximate"`

	// The type of location approximation. Always approximate.
	Type string `json:"type"`
}

type WebSearchOptions struct {
	// High level guidance for the amount of context window space to use for the search. One of low, medium, or high. medium is the default.
	SearchContextSize string `json:"search_context_size,omitempty"`

	// Approximate location parameters for the search.
	UserLocation *UserLocation `json:"user_location,omitempty"`
}

type ChatCompletionRequest struct {
	// A list of messages comprising the conversation so far.
	Messages []*ChatMessage `json:"messages,omitempty"`

	// ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API.
	Model string `json:"model,omitempty"`

	// Parameters for audio output. Required when audio output is requested with modalities: ["audio"]
	Audio *AudioOutput `json:"audio,omitempty"`

	// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
	// Defaults to 0
	FrequencyPenalty float64 `json:"frequency_penalty,omitempty"`

	// Modify the likelihood of specified tokens appearing in the completion.
	// Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
	// Defaults to null
	LogitBias any `json:"logit_bias,omitempty"`

	// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message. This option is currently not available on the gpt-4-vision-preview model.
	Logprobs bool `json:"logprobs,omitempty"`

	// An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens.
	MaxCompletionTokens int `json:"max_completion_tokens,omitempty"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard. Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
	Metadata any `json:"metadata,omitempty"`

	// Output types that you would like the model to generate for this request. Most models are capable of generating text, which is the default: ["text"]
	// The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"]
	Modalities []string `json:"modalities,omitempty"`

	// How many chat completion choices to generate for each input message.
	// Defaults to 1
	N int `json:"n,omitempty"`

	// Whether to enable parallel function calling during tool use. Default to true.
	ParallelToolCalls *bool `json:"parallel_tool_calls,omitempty"`

	// Configuration for a Predicted Output, which can greatly improve response times when large parts of the model response are known ahead of time. This is most common when you are regenerating a file with only minor changes to most of the content.
	Prediction *Prediction `json:"prediction,omitempty"`

	// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
	// Defaults to 0
	PresencePenalty float64 `json:"presence_penalty,omitempty"`

	// ReasoningEffort Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
	ReasoningEffort string `json:"reasoning_effort,omitempty"`

	// An object specifying the format that the model must output.
	// Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106.
	// Setting to { "type": "json_object" } enables JSON mode, which guarantees the message the model generates is valid JSON.
	// Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message.
	// Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit,
	// resulting in a long-running and seemingly "stuck" request.
	// Also note that the message content may be partially cut off if finish_reason="length",
	// which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
	ResponseFormat *ResponseFormat `json:"response_format,omitempty"`

	// This feature is in Beta. If specified, our system will make a best effort to sample deterministically,
	// such that repeated requests with the same seed and parameters should return the same result.
	// Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend.
	Seed int `json:"seed,omitempty"`

	// Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:
	//
	//	If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.
	//	If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
	//	If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
	//	When not set, the default behavior is 'auto'.
	//
	// Defaults to auto
	ServiceTier string `json:"service_tier,omitempty"`

	// Up to 4 sequences where the API will stop generating further tokens.
	Stop any `json:"stop,omitempty"`

	// Store Whether or not to store the output of this chat completion request for use in our model distillation or evals products.
	Store bool `json:"store,omitempty"`

	// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message.
	// Defaults to false
	Stream bool `json:"stream,omitempty"`

	// Options for streaming response. Only set this when you set stream: true.
	StreamOptions any `json:"stream_options,omitempty"`

	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	// We generally recommend altering this or top_p but not both.
	// Defaults to 1
	Temperature float64 `json:"temperature,omitempty"`

	// Controls which (if any) function is called by the model.
	// none means the model will not call a function and instead generates a message.
	// auto means the model can pick between generating a message or calling a function.
	// Specifying a particular function via {"type": "function", "function": {"name": "my_function"}} forces the model to call that function.
	// none is the default when no functions are present. auto is the default if functions are present.
	ToolChoice any `json:"tool_choice,omitempty"`

	// A list of tools the model may call.
	// Currently, only functions are supported as a tool.
	// Use this to provide a list of functions the model may generate JSON inputs for.
	Tools []any `json:"tools,omitempty"`

	// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
	TopLogprobs int `json:"top_logprobs,omitempty"`

	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	// We generally recommend altering this or temperature but not both.
	// Defaults to 1
	TopP float64 `json:"top_p,omitempty"`

	// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
	User string `json:"user,omitempty"`

	// This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
	WebSearchOptions *WebSearchOptions `json:"web_search_options,omitempty"`
}

func (cc *ChatCompletionRequest) AddMessage(cm *ChatMessage) {
	cc.Messages = append(cc.Messages, cm)
}

func (cc *ChatCompletionRequest) MessageRuneCount() int {
	cnt := 0
	for _, cm := range cc.Messages {
		switch v := cm.Content.(type) {
		case string:
			cnt += str.RuneCount(v)
		case []*MessageContent:
			for _, c := range v {
				cnt += str.RuneCount(c.Text)
			}
		}
	}
	return cnt
}

func (cc *ChatCompletionRequest) String() string {
	return toJSONIndent(cc)
}

type ChoiceAudio struct {
	// Base64 encoded audio bytes generated by the model, in the format specified in the request.
	Data string `json:"data,omitempty"`

	// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations.
	ExpiresAt int `json:"expires_at,omitempty"`

	// Unique identifier for this audio response.
	ID string `json:"id,omitempty"`

	// Transcript of the audio generated by the model.
	Transcript string `json:"transcript,omitempty"`
}

type URLCitation struct {
	// The index of the last character of the URL citation in the message.
	EndIndex int `json:"end_index,omitempty"`

	// The index of the first character of the URL citation in the message.
	StartIndex int `json:"start_index,omitempty"`

	// The title of the web resource.
	Title string `json:"title,omitempty"`

	// The URL of the web resource.
	URL string `json:"url,omitempty"`
}

type ChoiceAnnotation struct {
	// The type of the URL citation. Always url_citation.
	Type string `json:"type"`

	// A URL citation when using web search.
	URLCitation *URLCitation `json:"url_citation"`
}

type ChoiceMessage struct {
	// The contents of the message.
	Content string `json:"content,omitempty"`

	// The refusal message generated by the model.
	Refusal string `json:"refusal,omitempty"`

	// The role of the messages author.
	Role string `json:"role,omitempty"`

	// The name of the author of this message. name is required if role is function, and it should be the name of the function whose response is in the content. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
	Annotations []*ChoiceAnnotation `json:"annotations,omitempty"`

	// If the audio output modality is requested, this object contains data about the audio response from the model.
	Audio *ChoiceAudio `json:"audio,omitempty"`

	// The tool calls generated by the model, such as function calls.
	ToolCalls []*ToolCall `json:"tool_calls,omitempty"`
}

type ChatChoice struct {
	Index        int           `json:"index"`
	Message      ChoiceMessage `json:"message"`
	Logprobs     any           `json:"logprobs,omitempty"`
	FinishReason string        `json:"finish_reason"`
}

type CompletionTokensDetails struct {
	// When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion.
	AcceptedPredictionTokens int `json:"accepted_prediction_tokens"`

	// Audio input tokens generated by the model.
	AudioTokens int `json:"audio_tokens"`

	// Tokens generated by the model for reasoning.
	ReasoningTokens int `json:"reasoning_tokens"`

	// When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits.
	RejectedPredictionTokens int `json:"rejected_prediction_tokens"`
}

func (ctd *CompletionTokensDetails) Add(d *CompletionTokensDetails) {
	ctd.AcceptedPredictionTokens += d.AcceptedPredictionTokens
	ctd.AudioTokens += d.AudioTokens
	ctd.ReasoningTokens += d.ReasoningTokens
	ctd.RejectedPredictionTokens += d.RejectedPredictionTokens
}

func (ctd *CompletionTokensDetails) String() string {
	return fmt.Sprintf("AP: %d, A: %d, R: %d, RP: %d", ctd.AcceptedPredictionTokens, ctd.AudioTokens, ctd.ReasoningTokens, ctd.RejectedPredictionTokens)
}

type PromptTokensDetails struct {
	// Audio input tokens present in the prompt.
	AudioTokens int `json:"audio_tokens"`

	// Cached tokens present in the prompt.
	CachedTokens int `json:"cached_tokens"`
}

func (ptd *PromptTokensDetails) Add(d *PromptTokensDetails) {
	ptd.AudioTokens += d.AudioTokens
	ptd.CachedTokens += d.CachedTokens
}

func (ptd *PromptTokensDetails) String() string {
	return fmt.Sprintf("A: %d, C: %d", ptd.AudioTokens, ptd.CachedTokens)
}

type ChatUsage struct {
	CompletionTokens        int                     `json:"completion_tokens"`
	PromptTokens            int                     `json:"prompt_tokens"`
	TotalTokens             int                     `json:"total_tokens"`
	CompletionTokensDetails CompletionTokensDetails `json:"completion_tokens_details"`
	PromptTokensDetails     PromptTokensDetails     `json:"prompt_tokens_details"`
}

func (cu *ChatUsage) Add(u *ChatUsage) {
	cu.PromptTokens += u.PromptTokens
	cu.CompletionTokens += u.CompletionTokens
	cu.TotalTokens += u.TotalTokens
	cu.CompletionTokensDetails.Add(&u.CompletionTokensDetails)
	cu.PromptTokensDetails.Add(&u.PromptTokensDetails)
}

func (cu *ChatUsage) String() string {
	return fmt.Sprintf("C: %d (%s), P: %d (%s), T: %d",
		cu.CompletionTokens, cu.CompletionTokensDetails.String(),
		cu.PromptTokens, cu.PromptTokensDetails.String(),
		cu.TotalTokens)
}

type ChatCompletionResponse struct {
	ID                string        `json:"id,omitempty"`
	Choices           []*ChatChoice `json:"choices,omitempty"`
	Created           int64         `json:"created,omitempty"`
	Model             string        `json:"model,omitempty"`
	ServiceTier       string        `json:"service_tier,omitempty"`
	SystemFingerprint string        `json:"system_fingerprint,omitempty"`
	Object            string        `json:"object,omitempty"`
	Usage             ChatUsage     `json:"usage,omitempty"`
}

// Answer return first choice content
func (cc *ChatCompletionResponse) Answer() string {
	if len(cc.Choices) > 0 {
		return cc.Choices[0].Message.Content
	}
	return ""
}

func (cc *ChatCompletionResponse) ChoiceRuneCount() int {
	cnt := 0
	for _, c := range cc.Choices {
		cnt += str.RuneCount(c.Message.Content)
	}
	return cnt
}

func (cc *ChatCompletionResponse) String() string {
	return toJSONIndent(cc)
}
